#!/usr/bin/env python3

""" PLACEHOLDER. FILL THIS IN!
"""
import os
import sys
import random
import argparse
import numpy as np
import pandas as pd
import seaborn as sns
import matplotlib.pyplot as plt
from collections import Counter

import utils
from exceptions.exceptions import *
from utils.f1_website_scraping import *

# Globals
GRAPHS_DIR = utils.fetch_path("GRAPHS_DIR")
COLOURS = ["blue", "green", "red", "cyan", "magenta"]


def retirements(params: str):
    """
    Given a range of years and, using pandas to gather data from csv documents, generates
    two charts:
    
    [1] Bar chart representing the accumulative number of retirements per incident in the specified years.
        Examples of retirements: Engine, Puncture, Debris, Accident

    [2] Pie chart representing the percentage of retirements that the incidents contribute.
        This function fetches the incident classifications from "definitions.json"

    
    :param years: range of years to collect data and generate charts for. [Format "YYYY-YYYY"]
    :type str
    """
    if not params:
        raise MissingParametersException("year parameter required.")

    years = params.split("-")
    years = list(map(lambda d: int(d), years))
    if len(years) == 2:
        years = list(range(min(years), max(years) + 1))

    # Generate DataFrames
    status_df = utils.generate_dataframe_from_csv(utils.csv_documents()["STATUS"])

    retirement_causes = utils.fetch_definitions("RETIREMENT_CAUSES")  # fetch classifications for retirements.

    # Initialize some counters
    drivers = Counter()
    constructors = Counter()
    retirements = Counter()
    annual_retirements = Counter()

    # For each year, identify the drivers + teams who retired from each race and the 
    # cause for their retirement (stored in the status.csv document)
    
    for year in years:
        race_ids, results_df = utils.fetch_year_data(year)
        annual_retirements[year] = dict()

        for race in race_ids:
            race_results = results_df.loc[(results_df["raceId"] == race) & (results_df["positionText"] == "R")]

            for index, row in race_results.iterrows():
                driver, constructor, status = row.loc["driverId"], row.loc["constructorId"], row.loc["statusId"]
                drivers[driver] += 1
                constructors[constructor] += 1
                retirements[status] += 1

            if not annual_retirements[year].get(status):  # if the status does not exist in the dict, set it.
                annual_retirements[year][status] = 1
                continue
            annual_retirements[year][status] += 1

    status_code = dict()  # Create a cache for the status ids, rather than loading the entire list from csv.

    for status, count in retirements.items():
        if not status in status_code.keys():
            status_name = status_df.loc[status_df["statusId"] == status]["status"].values[0]
            status_code[status] = status_name

    total_df = pd.DataFrame(retirements.items(), columns=["statusId", "count"])
    total_df["statusId"] = total_df["statusId"].map(status_code)  # substitute the ids for the status names.
    total_df.sort_values(by=["count"], ascending=False, inplace=True)  # sort by count of retirements descending.

    # Configure Graph
    plt.clf()
    sns.set_theme(style="darkgrid", font="sans")
    fig = plt.gcf()
    fig.set_size_inches(18.5, 10.5)

    plt.title("Retirements in {}".format(params))

    # Plot Data
    sns.barplot(x="count", y="statusId", data=total_df)
    plt.xlabel("Count")
    plt.ylabel("Cause")

    # Export graph
    utils.export_graph("Retirements in {}".format(params),
                       "/{}/retirements_bc-{}.png".format(GRAPHS_DIR, params), use_legend=True)

    retirements_pc = dict()  # Initialize a dictionary for storing retirements percentages.

    for status, num in retirements.items():
        """
        if not status in status_code.keys():
            status_name = status_df.loc[status_df["statusId"] == status]["status"].values[0]
            status_code[status] = status_name
        """
        name = status_code[status]
        percentage = (num / sum(retirements.values())) * 100  # Calculate the retirement percentage against the total
        retirements_pc[name] = round(percentage, 3)  # Round percentage to two decimal points

    causes = list(retirement_causes.keys())
    retirement_stats = Counter()
    for cause, pc in retirements_pc.items():
        for c in causes:
            if cause in retirement_causes[c]:
                retirement_stats[c] += pc

    labels = list(retirement_stats.keys())
    percentages = list(retirement_stats.values())

    # Configure Graph
    plt.clf()
    sns.set_theme(style="darkgrid", font="sans")
    fig1, ax1 = plt.subplots()
    ax1.pie(percentages, labels=labels, autopct='%1.1f%%', shadow=True, startangle=90)
    ax1.axis('equal')

    # Export graph
    utils.export_graph("Retirements in {}".format(params),
                       "/{}/retirements_pie-{}.png".format(GRAPHS_DIR, params), use_legend=True)


def places_gained_lost(year: str):
    """
    This function, using a combination of pandas and BeautifulSoup,
    scraps the Formula1 website for race data for all races in the specified year. Using this data,
    it generates a bar chart representing the number of places that each driver gained and lost -
    calculated by differencing the drivers start position with their resulting position.
   
    :param year: year to collect data and generate charts for. [Format "YYYY"]
    :type str
    """
    if not year:
        raise MissingParametersException("year parameter required.")

    base_urls = fetch_base_urls(year)
    
    # Create a DataFrame for tracking the number of places gained/lost per driver.
    drivers_df = pd.DataFrame(columns=["Gained", "Lost"])

    for race in base_urls.values():

        # Generate dataframes from the tables scrapped using the urls - just return the index (driver) and position.
        starting_grid_url = race + "starting-grid.html"
        starting_grid = utils.generate_dataframe_from_url(starting_grid_url, index="Driver").Pos
        race_results_url = race + "race-results.html"
        resulting_grid = utils.generate_dataframe_from_url(race_results_url, index="Driver").Pos

        # Identify what drivers took part in the race, some of which may not have participated in qualifying.
        race_participants = resulting_grid.index.to_list()

        for driver in race_participants:

            if driver not in drivers_df.index:  # If driver not an index, append row.
                drivers_df.loc[driver] = 0

            try:
                start = starting_grid.index.get_loc(driver) + 1
            except KeyError:  # If driver not present in starting grid table, they started from back of grid.
                start = 20
            end = resulting_grid.index.get_loc(driver) + 1

            diff = start - end
            if diff >= 0:
                drivers_df.at[driver, "Gained"] += diff
            else:
                drivers_df.at[driver, "Lost"] += diff

    # Reindex using driver code. Will the map function work better here?
    drivers = drivers_df.index.to_list()
    codes = list(map(lambda d: d[-3:], drivers))
    drivers_df.rename(index=dict(zip(drivers, codes)), inplace=True)

   
    plt.clf()
    sns.set_theme(style="darkgrid", font="sans", context="paper")
    fig, ax = plt.subplots(figsize=(14, 10))
    ax = sns.barplot(x=drivers_df.index, y=drivers_df.Gained, data=drivers_df)
    ax = sns.barplot(x=drivers_df.index, y=drivers_df.Lost, data=drivers_df)
    plt.xticks(rotation=45, fontsize=10)

    utils.export_graph(
        f"Places Gained/Lost {year}", f"{GRAPHS_DIR}/gained_lost-{year}.png",  use_legend=False)


def fastest_lap_times(year: str, params: str = None):
    """
    Given a year and, using pandas to gather data from csv documents, generates
    a line chart representing each drivers fastest lap time for each race in the year specified.
    The chart also represents a calculated average of the fastest laps in each race.
    

    :param year: year to collect data and generate charts for. [Format "YYYY"]
    :type str

    :param params: comma-seperated list of drivers statistics to highlight. [Format "Average,Fastest,HAM"]
    :type str
    :default "Average,Fastest,Slowest"
    """
    if not year:
        raise MissingParametersException("year parameter required.")

    if int(year) not in range(2004, 2021):
        sys.exit("Woah, we don't have that year on file.")

    fastest_laps = dict()
    race_ids, full_df = utils.fetch_year_data(year, entity="LAPS")

    drivers_df = utils.generate_dataframe_from_csv(utils.csv_documents()["DRIVERS"])
    races_df = utils.generate_dataframe_from_csv(utils.csv_documents()["RACES"])
    lap_times_df = utils.generate_dataframe_from_csv(utils.csv_documents()["LAP_TIMES"])

    locations = list(races_df[races_df["raceId"].isin(race_ids)].sort_values(by=["raceId"], ascending=True)["name"])
    locations = list(map(lambda d: d.replace(" Grand Prix", "").upper(), locations))

    drivers = dict()
    
    for race in race_ids:
        grand_prix = locations[race_ids.index(race)]  # "Italian Grand Prix" -> "ITALIAN"
        race_fastest_lap = dict()

        race_participants = full_df.loc[full_df.raceId == race].index.to_list()
        
        race_lap_times = lap_times_df.loc[lap_times_df.raceId == race]

        average = race_lap_times.milliseconds.mean()
        fastest = race_lap_times.milliseconds.min()
        slowest = race_lap_times.milliseconds.max()

        race_fastest_lap["Average"] = average
        race_fastest_lap["Fastest"] = fastest

        for driver in race_participants:
            driver_fastest = race_lap_times.loc[race_lap_times.driverId == driver].milliseconds.min()

            # Get driver code
            if not driver in drivers.keys():
                driver_code = drivers_df.loc[drivers_df.driverId == driver].code.values[0]
                drivers[driver] = driver_code
            driver_code = drivers[driver]

            race_fastest_lap[driver] = driver_fastest
        
        fastest_laps[grand_prix] = race_fastest_lap

    # Create + configure DataFrame
    fastest_laps_df = pd.DataFrame(fastest_laps).transpose()
    fastest_laps_df.index.name = "Grand Prix"
    fastest_laps_df.replace("\\N", np.NaN, inplace=True)
    fastest_laps_df.rename(columns=drivers, inplace=True)  # replace driverIds with driver codes.

    fastest_laps_df = fastest_laps_df.apply(lambda d: d / 1000, axis=1)  # Convert times from microseconds to seconds

    # Configure Graph
    plt.clf()
    sns.set_theme(style="darkgrid", font="sans")
    fig = plt.gcf()
    fig.set_size_inches(18.5, 10.5)
    plt.title("Lap Times {}".format(year))
    plt.xlabel("Grand Prix")
    plt.xticks(rotation=70)
    plt.ylabel("Time (seconds)")
    plt.grid(True)

    params = params.split(",") if params else ['Average', 'Fastest']  # set default if not specified

    # Plot data
    for index, column in enumerate(fastest_laps_df.columns):

        for param in params:
            if column == param:
                color = COLOURS.pop(random.randrange(len(COLOURS)))
                plt.plot(fastest_laps_df.index, fastest_laps_df[column], color=color, label=param, linestyle="--")
            continue

        plt.plot(fastest_laps_df.index, fastest_laps_df[column], color="grey", label=None, alpha=0.25)

    # Export graph
    utils.export_graph("Fastest Laps {}".format(year),
                       "/{}/fastest-laps-{}.png".format(GRAPHS_DIR, year), use_legend=True)



def drivers_season(year: str, params: str = None):
    """
    Given a year and, using pandas to gather data from csv documents, generates
    two charts:

    [1] Line charts detailing the count for each of the below categories per driver:
        - Wins
        - Podiums
        - Pole positions
        - Wins from pole positions
        - Fastest Laps
    
    [2] Line chart representing the points accumulated by each driver in the year specified.

    :param year: year to collect data and generate charts for. [Format "YYYY"]
    :type str

    :param params: comma-seperated list of drivers to highlight. [Format "HAM,PER,MSC"]
    :type str
    """
    if not year:
        raise MissingParametersException

    race_ids, full_df = utils.fetch_year_data(year, entity="DRIVER")
    results_df = full_df[full_df["raceId"].isin(race_ids)]

    # Get locations
    races_df = utils.generate_dataframe_from_csv(utils.csv_documents()["RACES"])
    locations = list(races_df[races_df["raceId"].isin(race_ids)].sort_values(by=["raceId"], ascending=True)["name"])
    locations = list(map(lambda d: d.replace(" Grand Prix", "").upper(), locations))

    """
    Driver Statistics
    """

    # Fetch data from DataFrame, store in dictionaries.
    wins = results_df.loc[results_df["positionOrder"] == 1].groupby("code").count()["resultId"].to_dict()
    poles = results_df.loc[results_df["grid"] == 1].groupby("code").count()["resultId"].to_dict()
    wins_from_pole = results_df.loc[(results_df["positionOrder"] == 1) & (results_df["grid"] == 1)].groupby("code").count()["resultId"].to_dict()
    podiums =  results_df.loc[results_df["positionOrder"] <= 3].groupby("code").count()["resultId"].to_dict()
    retirements = results_df.loc[results_df["positionText"] == "R"].groupby("code").count()["resultId"].to_dict()

    # Why did this need to be done in a Counter?
    fastest_laps = Counter()
    for race in race_ids:
        race_df = results_df.loc[results_df["raceId"] == race]
        driver = race_df[race_df.fastestLapTime == race_df.fastestLapTime.min()]["code"].values[0]
        fastest_laps[driver] += 1

    # Create DataFrame from dictionaries, add columns names, fill NaNs with zeros.
    data = [wins, poles, wins_from_pole, podiums, retirements, fastest_laps]
    stats_df = pd.DataFrame(data).transpose()
    stats_df.columns = ["wins", "poles", "wins_from_pole", "podiums", "retirements", "fastest_lap"]
    stats_df.fillna(0, inplace=True)

    """
    Plot
    """
    plt.clf()

    sns.set_theme(style="darkgrid", context="paper")
    f, (ax1, ax2, ax3, ax4, ax5) = plt.subplots(5, 1, figsize=(14, 10), sharex=True)

    sns.lineplot(x=stats_df.index, y=stats_df.wins, ax=ax1)
    ax1.set_ylabel("Wins", fontsize=10)
    sns.lineplot(x=stats_df.index, y=stats_df.podiums, ax=ax2)
    ax2.set_ylabel("Podiums", fontsize=10)
    sns.lineplot(x=stats_df.index, y=stats_df.poles, ax=ax3)
    ax3.set_ylabel("Poles", fontsize=10)
    sns.lineplot(x=stats_df.index, y=stats_df.wins_from_pole, ax=ax4)
    ax4.set_ylabel("Wins from Pole", fontsize=10)
    sns.lineplot(x=stats_df.index, y=stats_df.fastest_lap, ax=ax5)
    ax5.set_ylabel("Fastest Lap", fontsize=10)

    plt.xticks(rotation=45, fontsize=10)
    sns.despine()
    plt.setp(f.axes, yticks=[])

    # Export graph
    utils.export_graph("Drivers Stats {}".format(year),
                       "/{}/driver_stats-{}.png".format(GRAPHS_DIR, year), use_legend=False)

    """
    Driver Points
    """

    race_results = dict()
    for race in race_ids:
        data = full_df.loc[full_df["raceId"] == race][["code", "points"]].to_dict()
        drivers, points = list(data["code"].values()), list(data["points"].values())

        for d in range(0, len(drivers)):
            driver = drivers[d]
            point = int(points[d])

            if driver in race_results.keys():
                race_results[driver].append(point)
                continue
            race_results[driver] = [point]

        
        # If a driver does not participant in this race, append a zero to their points 
        for not_racing in [x for x in race_results.keys() if x not in drivers]:
            race_results[not_racing].append(0)

    # Prepend a range of zeros for drivers who did not participate from the opening race.
    for driver in race_results.keys():
        missed = len(race_ids) - len(race_results[driver])

        for missed_race in range(missed):
            race_results[driver].insert(0, 0)

    # Configure Graph
    plt.clf()
    sns.set_theme(style="darkgrid", font="sans")
    fig, ax = plt.subplots()
    fig.set_size_inches(18.5, 10.5)
    plt.title("Drivers Championship {}".format(year))
    plt.xlabel("Grand Prix")
    plt.xticks(rotation=70)
    plt.ylabel("Points")
    plt.grid(True)

    # Plot Data
    for driver, points in race_results.items():
        accum = list(np.cumsum(points))
        color, alpha, marker = "grey", 0.25, "."
        if params and driver.upper() in [x.upper() for x in params.split(",")]:
            color = COLOURS.pop(random.randrange(len(COLOURS)))
            alpha, marker = 1, "x"
        ax.plot(locations, accum, color=color, label=driver, marker=marker, alpha=alpha)

    # Export graph
    utils.export_graph("Drivers Championship {}".format(year),
                       "/{}/drivers_championship-{}.png".format(GRAPHS_DIR, year), use_legend=True)


if __name__ == "__main__":

    # Handle arguments
    parser = argparse.ArgumentParser()
    parser.add_argument("-o", "--option")
    parser.add_argument("-p", "--params")
    parser.add_argument("-y", "--year")
    args = parser.parse_args()

    options = [
        "fastest-laps",
        "drivers-year",
        "gained-lost",
        "retirements"
    ]

    # Set params as None if not set by user input
    params = args.params if args.params else None

    if not args.option or args.option not in options:
        sys.exit("Please read documentation on how to use.")

    if args.option == "drivers-year":
        drivers_season(args.year, params=params)

    if args.option == "retirements":
        retirements(args.year)

    if args.option == "gained-lost":
        places_gained_lost(args.year)

    if args.option == "fastest-laps":
        fastest_lap_times(args.year, params=params)